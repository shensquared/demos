<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Linear Separator</title>
        <!-- Include Plotly.js -->
        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
        <style>
            body,
            html {
                margin: 0;
                padding: 0;
                height: 100%;
            }
            .plots-container {
                display: flex;
                justify-content: space-between; /* Adjusts alignment */
                align-items: center;
                height: 80vh; /* Ensure both plots have the same height */
            }

            #plot {
                flex-grow: 1;
                width: 70%;
                height: 90%;
            }

            #plot2D {
                width: 30%; /* Set #plot2D to be 30% wide */
                /* height: 100%; */
            }

            .slider-container {
                display: flex; /* Enables flexbox layout */
                justify-content: space-around; /* Distributes space around items */
                align-items: center; /* Vertically centers items */
                padding: 20px; /* Adds some padding around the container */
            }
            .slider-group {
                display: flex; /* Enables flexbox within each slider group */
                flex-direction: column; /* Aligns the label and slider vertically */
                align-items: center; /* Centers the items horizontally */
            }
            .footer {
                display: flex;
                justify-content: center;
                align-items: center;
                width: 100%;
                background-color: #f8f9fa;
                color: #6c757d;
                text-align: center;
                padding: 10px 0;
                margin: 50px;
            }
            .footer a {
                color: #007bff;
                text-decoration: none;
            }
            .footer a:hover {
                text-decoration: underline;
            }
        </style>
    </head>
    <body>
        <div class="plots-container">
            <div id="plot"></div>
            <div id="plot2D"></div>
        </div>
        <!-- Slider controls wrapped in a div container -->
        <div class="slider-container">
            <div class="slider-group">
                <label for="theta_1">θ₁:</label>
                <input
                    type="range"
                    id="theta_1"
                    min="-2"
                    max="2"
                    value="0.1"
                    step="0.1"
                    oninput="updatePlot()"
                />
            </div>
            <div class="slider-group">
                <label for="theta_2">θ₂:</label>
                <input
                    type="range"
                    id="theta_2"
                    min="-2"
                    max="2"
                    value="-2"
                    step="0.1"
                    oninput="updatePlot()"
                />
            </div>
            <div class="slider-group">
                <label for="theta_0">θ₀:</label>
                <input
                    type="range"
                    id="theta_0"
                    min="-1"
                    max="1"
                    value="0"
                    step="0.1"
                    oninput="updatePlot()"
                />
            </div>
            <button id="toggleZ0">Toggle z=0 Surface</button>
        </div>
        <div class="footer">
            Built with ❤️ by&nbsp;
            <a href="https://shenshen.mit.edu" target="_blank"> Shen²</a>
        </div>
        <script>
            let z0SurfaceVisible = false; // Tracks if the z=0 surface is currently supposed to be visible
            let z0SurfaceAdded = false;
            // Initialize the layout

            var customCameraSettings = {
                eye: { x: 0, y: -1, z: 2 }, // Adjusts the view point for the 3D plot
                up: { x: 0, y: 0, z: 1 }, // Sets the up direction for the 3D plot
                center: { x: 0, y: 0, z: 0 }, // Centers the view
            };

            var layout = {
                title: "View of the feature space (x₁ and x₂) and decision helper (z)",
                scene: {
                    xaxis: { title: "x₁", range: [-2, 2] },
                    yaxis: { title: "x₂", range: [-2, 2] },
                    zaxis: { title: "z", range: [-6, 6] },
                    aspectmode: "manual", // Fix the aspect ratio
                    aspectratio: { x: 1, y: 1, z: 1 }, // Set the aspect ratio to 1:1:1

                    camera: customCameraSettings,
                },
                sliders: [
                    {
                        currentvalue: { prefix: "Theta 1: " },
                        pad: { t: 50 },
                        steps: [],
                        len: 0.5,
                    },
                    {
                        currentvalue: { prefix: "Theta 2: " },
                        pad: { t: 50 },
                        steps: [],
                        len: 0.5,
                    },
                    {
                        currentvalue: { prefix: "Theta 0: " },
                        pad: { t: 50 },
                        steps: [],
                        len: 0.5,
                    },
                ],
            };

            // Custom color scale
            var customColorscale = [
                [0, "blue"], // Negative values
                [0.49, "blue"], // Transition from blue to grey
                [0.5, "grey"], // Zero value
                [0.51, "grey"], // Transition from grey to red
                [1, "red"], // Positive values
            ];

            function generateSurfaceData(theta_1, theta_2, theta_0) {
                var a = [],
                    b = [],
                    z = [];

                // Generate x and y grid
                for (var i = -2; i <= 2; i++) {
                    a.push(i);
                }
                for (var j = -2; j <= 2; j++) {
                    b.push(j);
                }

                // Generate z values as a 2D array
                for (var i = 0; i < a.length; i++) {
                    var zRow = []; // Create a new row for each value of a
                    for (var j = 0; j < b.length; j++) {
                        zRow.push(theta_2 * a[i] + theta_1 * b[j] + theta_0); // Compute z for each combination of a and b
                    }
                    z.push(zRow); // Add the row to the z matrix
                }

                return {
                    x: a, // x and y arrays define the grid, and should only be 1D
                    y: b,
                    z: z, // z should be a 2D array matching the grid defined by x and y
                    type: "surface",
                    showscale: false,
                    colorscale: customColorscale,
                };
            }

            function update2DPlot(theta_1, theta_2, theta_0) {
                if (theta_2 === 0) {
                    // Handle the case where theta_2 = 0: Plot a vertical line at x1 = -theta_0/theta_1
                    // Since it's a vertical line, x1 is constant, and x2 ranges across the plot
                    if (theta_1 === 0) {
                        // Ensure theta_1 is not 0 to avoid division by zero
                        // Handle special case or show error/warning
                        console.error(
                            "Theta_1 and Theta_2 are both 0 - cannot plot a line."
                        );
                        return; // Exit the function or handle accordingly
                    }
                    var x1 = -theta_0 / theta_1;
                    traces.push({
                        x: [x1, x1],
                        y: [-2, 2], // Use the full range of the plot for y
                        mode: "lines",
                        type: "scatter",
                        name: "Separator Line",
                    });
                } else if (theta_1 === 0) {
                    var x2 = -theta_0 / theta_2;
                    traces.push({
                        x: [-2, 2],
                        y: [x2, x2], // Use the full range of the plot for y
                        mode: "lines",
                        type: "scatter",
                        name: "Separator Line",
                    });
                } else {
                    // Define a range of x1 values to plot the line
                    var x1 = Array.from({ length: 10 }, (_, i) => -3 + i * 1);

                    // Calculate x2 values based on the line equation: Theta1*x1 + Theta2*x2 + Theta0 = 0
                    // Rearranged to x2 = (-Theta0 - Theta1*x1) / Theta2
                    var x2 = x1.map(
                        (x1Val) => (-theta_0 - theta_1 * x1Val) / theta_2
                    );
                }

                var trace = {
                    x: x1,
                    y: x2,
                    mode: "lines",
                    type: "scatter",
                    name: "Separator Line",
                };

                var layout = {
                    title: "View of the feature space (x₁ and x₂)",
                    xaxis: { title: "x₁", range: [-2, 2] },
                    yaxis: { title: "x₂", range: [-2, 2], scaleanchor: "x" },
                    annotations: [
                        {
                            x: theta_1, // End point of the arrow (x)
                            y: theta_2, // End point of the arrow (y)
                            ax: 0, // Starting point relative to x
                            ay: 0, // Starting point relative to y
                            xref: "x",
                            yref: "y",
                            axref: "x",
                            ayref: "y",
                            showarrow: true,
                            arrowhead: 2,
                            arrowsize: 1,
                            arrowwidth: 2,
                            arrowcolor: "red",
                        },
                    ],
                };

                Plotly.newPlot("plot2D", [trace], layout);
            }

            function generateZ0SurfaceData(theta_1, theta_2, theta_0) {
                var x = [],
                    y = [],
                    z = [];

                // Generate x and y grid
                for (var i = -2; i <= 2; i += 1) {
                    // Adjust step for finer grid if needed
                    x.push(i);
                }
                for (var j = -2; j <= 2; j += 1) {
                    // Adjust step for finer grid if needed
                    y.push(j);
                }

                // Generate z values as a 2D array
                for (var i = 0; i < x.length; i++) {
                    var zRow = [];
                    for (var j = 0; j < y.length; j++) {
                        zRow.push(0);
                    }
                    z.push(zRow);
                }

                return {
                    x: x,
                    y: y,
                    z: z,
                    type: "surface",
                    showscale: false,
                    opacity: 0.5,
                    colorscale: [
                        [0, "rgba(128,128,128,0.5)"],
                        [1, "rgba(128,128,128,0.5)"],
                    ],
                    name: "z0Surface", // Add a unique name for identification
                    visible: false, // Initially hidden
                };
            }
            // Function to update the plot when sliders change
            function updatePlot() {
                var theta_1 = parseFloat(
                    document.getElementById("theta_1").value
                );
                var theta_2 = parseFloat(
                    document.getElementById("theta_2").value
                );
                var theta_0 = parseFloat(
                    document.getElementById("theta_0").value
                );

                var data = generateSurfaceData(theta_1, theta_2, theta_0);
                console.log(theta_1, theta_2, theta_0);
                console.log(data);
                var z0data = generateZ0SurfaceData();
                Plotly.react("plot", [data, z0data], layout);
                update2DPlot(theta_1, theta_2, theta_0);
                // Inside your updatePlot function, after generating the main surface data
                var traceIndex = findTraceIndexByName("plot", "z0Surface");
                if (traceIndex !== -1) {
                    // Apply the current visibility state to the z0 surface when updating the plot
                    Plotly.restyle(
                        "plot",
                        { visible: z0SurfaceVisible ? true : "legendonly" },
                        [traceIndex]
                    );
                }
            }

            // Initialize the plot
            updatePlot();
            function findTraceIndexByName(plotId, traceName) {
                var plotElement = document.getElementById(plotId);
                if (plotElement && plotElement.data) {
                    // Search through the plot data for a trace with the matching name
                    for (var i = 0; i < plotElement.data.length; i++) {
                        if (plotElement.data[i].name === traceName) {
                            return i; // Return the index of the found trace
                        }
                    }
                }
                return -1; // Return -1 if the trace is not found
            }
            document
                .getElementById("toggleZ0")
                .addEventListener("click", function () {
                    z0SurfaceVisible = !z0SurfaceVisible; // Toggle the visibility state
                    var visibilityState = z0SurfaceVisible
                        ? true
                        : "legendonly"; // Use 'legendonly' or false as needed

                    // Find the index of the z=0 surface
                    var traceIndex = findTraceIndexByName("plot", "z0Surface");
                    if (traceIndex !== -1) {
                        Plotly.restyle("plot", { visible: visibilityState }, [
                            traceIndex,
                        ]);
                    }
                });
        </script>
    </body>
</html>
