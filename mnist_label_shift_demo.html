<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Label Shift — MNIST Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #f5f3ef;
            --surface: #ffffff;
            --ink: #1a1a1a;
            --ink-light: #6b6b6b;
            --ink-faint: #a3a3a3;
            --rule: #d4d0c8;
            --rule-light: #e8e5de;
            --accent: #c03030;
            --good: #1a7a3a;
            --good-bg: #e8f5ec;
            --bad: #c03030;
            --bad-bg: #fce8e8;
            --neutral-bg: #f0ede7;
            --mono: 'IBM Plex Mono', 'SF Mono', 'Menlo', monospace;
            --sans: 'IBM Plex Sans', -apple-system, sans-serif;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: var(--sans);
            font-size: 14px;
            line-height: 1.5;
            color: var(--ink);
            background: var(--bg);
            min-height: 100vh;
        }

        /* === LAYOUT === */
        .app {
            display: grid;
            grid-template-columns: 340px 1fr;
            grid-template-rows: auto 1fr;
            min-height: 100vh;
        }

        .header {
            grid-column: 1 / -1;
            padding: 16px 24px;
            border-bottom: 2px solid var(--ink);
            display: flex;
            align-items: baseline;
            gap: 24px;
            background: var(--surface);
        }
        .header h1 {
            font-family: var(--mono);
            font-size: 16px;
            font-weight: 600;
            letter-spacing: -0.02em;
            white-space: nowrap;
        }
        .header .subtitle {
            font-size: 13px;
            color: var(--ink-light);
        }
        .header .metrics-bar {
            margin-left: auto;
            display: flex;
            gap: 20px;
            font-family: var(--mono);
            font-size: 12px;
        }
        .metrics-bar .m-item { display: flex; align-items: baseline; gap: 6px; }
        .metrics-bar .m-label { color: var(--ink-faint); text-transform: uppercase; letter-spacing: 0.05em; font-size: 10px; }
        .metrics-bar .m-value { font-weight: 600; font-size: 14px; }
        .metrics-bar .m-value.good { color: var(--good); }
        .metrics-bar .m-value.bad { color: var(--bad); }

        /* === LEFT PANEL === */
        .panel-left {
            border-right: 1px solid var(--rule);
            background: var(--surface);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .panel-section {
            padding: 16px 20px;
            border-bottom: 1px solid var(--rule-light);
        }
        .panel-section:last-child { border-bottom: none; }

        .panel-label {
            font-family: var(--mono);
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--ink-faint);
            margin-bottom: 10px;
        }

        /* Status messages */
        .status {
            font-family: var(--mono);
            font-size: 12px;
            padding: 8px 10px;
            border-left: 3px solid var(--rule);
            background: var(--neutral-bg);
            margin-bottom: 10px;
        }
        .status.ok { border-left-color: var(--good); background: var(--good-bg); }
        .status.err { border-left-color: var(--bad); background: var(--bad-bg); }
        .status.loading::before {
            content: '';
            display: inline-block;
            width: 10px; height: 10px;
            border: 2px solid var(--rule);
            border-top-color: var(--ink);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Distribution bars */
        .dist-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 3px;
            font-family: var(--mono);
            font-size: 12px;
        }
        .dist-digit {
            width: 14px;
            text-align: right;
            color: var(--ink-light);
        }
        .dist-bar-track {
            flex: 1;
            height: 14px;
            background: var(--neutral-bg);
            position: relative;
        }
        .dist-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        .dist-bar-fill.maj { background: var(--good); opacity: 0.6; }
        .dist-bar-fill.min { background: var(--bad); opacity: 0.5; }
        .dist-count {
            width: 28px;
            text-align: right;
            font-size: 11px;
            color: var(--ink-faint);
        }

        /* Buttons */
        .btn {
            font-family: var(--mono);
            font-size: 12px;
            font-weight: 500;
            padding: 8px 14px;
            border: 1px solid var(--ink);
            background: var(--surface);
            color: var(--ink);
            cursor: pointer;
            transition: background 0.15s, color 0.15s;
        }
        .btn:hover { background: var(--ink); color: var(--surface); }
        .btn:disabled {
            border-color: var(--rule);
            color: var(--ink-faint);
            cursor: not-allowed;
            background: var(--neutral-bg);
        }
        .btn:disabled:hover { background: var(--neutral-bg); color: var(--ink-faint); }
        .btn-row { display: flex; gap: 8px; margin-top: 10px; }

        /* Digit picker */
        .digit-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 4px;
        }
        .digit-btn {
            font-family: var(--mono);
            font-size: 14px;
            font-weight: 600;
            padding: 6px 0;
            border: 1px solid var(--rule);
            background: var(--surface);
            cursor: pointer;
            text-align: center;
            transition: all 0.15s;
            position: relative;
        }
        .digit-btn:hover { border-color: var(--ink); }
        .digit-btn.active { background: var(--ink); color: var(--surface); border-color: var(--ink); }
        .digit-btn.maj::after, .digit-btn.min::after {
            content: '';
            position: absolute;
            bottom: 1px; left: 25%; right: 25%;
            height: 2px;
        }
        .digit-btn.maj::after { background: var(--good); }
        .digit-btn.min::after { background: var(--bad); }
        .digit-btn.evaluated { background: var(--neutral-bg); }
        .digit-btn.evaluated.active { background: var(--ink); color: var(--surface); }

        .digit-legend {
            display: flex; gap: 12px; margin-top: 8px;
            font-size: 11px; color: var(--ink-light);
        }
        .digit-legend span::before {
            content: '';
            display: inline-block;
            width: 10px; height: 2px;
            margin-right: 4px;
            vertical-align: middle;
        }
        .digit-legend .leg-maj::before { background: var(--good); }
        .digit-legend .leg-min::before { background: var(--bad); }

        /* Training progress */
        .epoch-bar-track {
            width: 100%;
            height: 4px;
            background: var(--neutral-bg);
            margin: 8px 0;
        }
        .epoch-bar-fill {
            height: 100%;
            background: var(--ink);
            transition: width 0.2s;
        }
        .epoch-text {
            font-family: var(--mono);
            font-size: 11px;
            color: var(--ink-light);
        }

        /* === RIGHT PANEL === */
        .panel-right {
            overflow-y: auto;
            padding: 20px 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: var(--surface);
            border: 1px solid var(--rule);
            padding: 20px;
        }
        .card-title {
            font-family: var(--mono);
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: var(--ink-faint);
            margin-bottom: 14px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--rule-light);
        }

        /* Test result */
        .test-result {
            display: flex;
            align-items: flex-start;
            gap: 24px;
        }
        .test-image-wrap {
            flex-shrink: 0;
            background: #000;
            padding: 6px;
        }
        .mnist-canvas {
            display: block;
            width: 72px; height: 72px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            background: #000;
        }
        .mnist-canvas-lg {
            width: 100px; height: 100px;
        }
        .test-info {
            flex: 1;
            font-family: var(--mono);
            font-size: 13px;
        }
        .test-info .row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid var(--rule-light);
        }
        .test-info .row:last-child { border-bottom: none; }
        .test-info .label { color: var(--ink-light); }
        .test-info .val { font-weight: 600; }
        .test-info .val.correct { color: var(--good); }
        .test-info .val.wrong { color: var(--bad); }

        .conf-track {
            height: 6px;
            background: var(--neutral-bg);
            margin-top: 8px;
        }
        .conf-fill {
            height: 100%;
            transition: width 0.3s;
        }

        /* Class analysis */
        .analysis-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }
        .analysis-acc {
            font-family: var(--mono);
            font-size: 28px;
            font-weight: 600;
            line-height: 1;
        }
        .analysis-meta {
            font-size: 13px;
            color: var(--ink-light);
        }

        .sample-row {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin: 12px 0;
        }
        .sample-item {
            text-align: center;
        }
        .sample-item canvas {
            display: block;
            width: 48px; height: 48px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            background: #000;
        }
        .sample-item .tag {
            font-family: var(--mono);
            font-size: 10px;
            font-weight: 600;
            margin-top: 2px;
        }
        .sample-item .tag.ok { color: var(--good); }
        .sample-item .tag.fail { color: var(--bad); }
        .sample-item.wrong canvas {
            outline: 2px solid var(--bad);
            outline-offset: -2px;
        }

        .chart-wrap {
            height: 180px;
            margin-top: 12px;
        }

        .insight-box {
            padding: 14px 16px;
            border-left: 3px solid var(--ink);
            background: var(--neutral-bg);
            margin-bottom: 12px;
            font-size: 13px;
            line-height: 1.6;
        }
        .insight-box strong { font-family: var(--mono); font-size: 12px; }
        .insight-box ul, .insight-box ol {
            margin-left: 18px;
            margin-top: 6px;
        }

        /* Placeholder states */
        .placeholder {
            font-family: var(--mono);
            font-size: 12px;
            color: var(--ink-faint);
            padding: 30px 20px;
            text-align: center;
            border: 1px dashed var(--rule);
        }

        /* Two-col layout for right panel */
        .two-col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1100px) {
            .app { grid-template-columns: 300px 1fr; }
            .two-col { grid-template-columns: 1fr; }
        }
        @media (max-width: 800px) {
            .app { grid-template-columns: 1fr; }
            .panel-left { border-right: none; border-bottom: 1px solid var(--rule); }
            .header { flex-wrap: wrap; }
            .header .metrics-bar { margin-left: 0; }
        }
    </style>
</head>
<body>
<div class="app">
    <!-- HEADER -->
    <div class="header">
        <h1>Label Shift</h1>
        <span class="subtitle">MNIST demo — train on biased data, test on balanced</span>
        <div class="metrics-bar">
            <div class="m-item">
                <span class="m-label">Train Acc</span>
                <span class="m-value" id="totalAccuracy">—</span>
            </div>
            <div class="m-item">
                <span class="m-label">Majority</span>
                <span class="m-value good" id="majorityAcc">—</span>
            </div>
            <div class="m-item">
                <span class="m-label">Minority</span>
                <span class="m-value bad" id="minorityAcc">—</span>
            </div>
            <div class="m-item">
                <span class="m-label">Gap</span>
                <span class="m-value bad" id="accGap">—</span>
            </div>
        </div>
    </div>

    <!-- LEFT PANEL -->
    <div class="panel-left">
        <!-- Data status -->
        <div class="panel-section">
            <div class="panel-label">1 / Data</div>
            <div id="dataStatus" class="status loading">Loading MNIST dataset…</div>
        </div>

        <!-- Distribution -->
        <div class="panel-section" id="trainSection" style="display:none;">
            <div class="panel-label">Training Distribution</div>
            <div id="distBars"></div>
            <div class="btn-row">
                <button class="btn" id="trainButton" onclick="startTraining()">Train</button>
                <button class="btn" onclick="resetDemo()">Reset</button>
            </div>
            <div id="trainingProgress" style="display:none; margin-top: 10px;">
                <div class="epoch-bar-track"><div class="epoch-bar-fill" id="epochBarFill" style="width:0%"></div></div>
                <div class="epoch-text" id="epochInfo"></div>
            </div>
            <div id="trainingResult"></div>
        </div>

        <!-- Test -->
        <div class="panel-section">
            <div class="panel-label">2 / Test</div>
            <button class="btn" id="testButton" onclick="testRandomImage()" disabled style="width:100%">Test Random Image</button>
        </div>

        <!-- Analyze -->
        <div class="panel-section">
            <div class="panel-label">3 / Analyze by Class</div>
            <div class="digit-grid" id="classButtons"></div>
            <div class="digit-legend">
                <span class="leg-maj">majority (30%)</span>
                <span class="leg-min">minority (1.4%)</span>
            </div>
        </div>

        <!-- Summary trigger -->
        <div class="panel-section">
            <div class="panel-label">4 / Summary</div>
            <button class="btn" id="shiftButton" onclick="showLabelShiftSummary()" disabled style="width:100%">Show Label Shift Summary</button>
        </div>
    </div>

    <!-- RIGHT PANEL -->
    <div class="panel-right">
        <div id="testResultCard" class="card" style="display:none;">
            <div class="card-title">Single Image Prediction</div>
            <div id="individualTest"></div>
        </div>

        <div id="analysisCard" class="card" style="display:none;">
            <div class="card-title" id="analysisTitle">Class Analysis</div>
            <div id="classAnalysis"></div>
        </div>

        <div id="summaryCard" class="card" style="display:none;">
            <div class="card-title">Label Shift Effect</div>
            <div id="shiftAnalysis"></div>
        </div>

        <div id="placeholderCard" class="placeholder">
            Train a model, then test images or analyze classes.<br>Results will appear here.
        </div>
    </div>
</div>

<script>
// === Constants ===
const IMAGE_SIZE = 784;
const NUM_CLASSES = 10;
const NUM_DATASET_ELEMENTS = 65000;
const MAJORITY_CLASSES = new Set([0, 3, 9]);
const MAJORITY_COUNT = 300;
const MINORITY_COUNT = 14;
const TEST_PER_CLASS = 100;
const TRAIN_EPOCHS = 20;

const MNIST_IMAGES_SPRITE_PATH = 'https://storage.googleapis.com/learnjs-data/model-builder/mnist_images.png';
const MNIST_LABELS_PATH = 'https://storage.googleapis.com/learnjs-data/model-builder/mnist_labels_uint8';

// === State ===
let mnistData = null;
let model = null;
let trainIndices = [];
let testIndicesByClass = {};
let networkTrained = false;
let classResults = {};
let trainingChart = null;
let finalTrainAcc = 0;

// === MNIST Data Loading ===
async function loadMnistData() {
    const imgPromise = new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = '';
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const datasetBytesBuffer = new ArrayBuffer(NUM_DATASET_ELEMENTS * IMAGE_SIZE * 4);
            const chunkSize = 5000;
            canvas.width = img.width;
            canvas.height = chunkSize;
            for (let i = 0; i < NUM_DATASET_ELEMENTS / chunkSize; i++) {
                const view = new Float32Array(datasetBytesBuffer, i * IMAGE_SIZE * chunkSize * 4, IMAGE_SIZE * chunkSize);
                ctx.drawImage(img, 0, i * chunkSize, img.width, chunkSize, 0, 0, img.width, chunkSize);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                for (let j = 0; j < imageData.data.length / 4; j++) {
                    view[j] = imageData.data[j * 4] / 255;
                }
            }
            resolve(new Float32Array(datasetBytesBuffer));
        };
        img.onerror = () => reject(new Error('Failed to load MNIST images'));
        img.src = MNIST_IMAGES_SPRITE_PATH;
    });
    const labelsPromise = fetch(MNIST_LABELS_PATH)
        .then(r => { if (!r.ok) throw new Error('Failed to load labels'); return r.arrayBuffer(); })
        .then(buf => new Uint8Array(buf));
    const [images, labelsOneHot] = await Promise.all([imgPromise, labelsPromise]);
    const labels = new Uint8Array(NUM_DATASET_ELEMENTS);
    for (let i = 0; i < NUM_DATASET_ELEMENTS; i++) {
        for (let j = 0; j < 10; j++) {
            if (labelsOneHot[i * 10 + j] === 1) { labels[i] = j; break; }
        }
    }
    return { images, labels };
}

// === Dataset Creation ===
function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

function createDatasets() {
    const byLabel = Array.from({ length: 10 }, () => []);
    for (let i = 0; i < NUM_DATASET_ELEMENTS; i++) {
        byLabel[mnistData.labels[i]].push(i);
    }
    byLabel.forEach(arr => shuffleArray(arr));
    trainIndices = [];
    testIndicesByClass = {};
    for (let d = 0; d < 10; d++) {
        const pool = byLabel[d];
        const nTrain = MAJORITY_CLASSES.has(d) ? MAJORITY_COUNT : MINORITY_COUNT;
        for (let i = 0; i < nTrain; i++) trainIndices.push(pool[i]);
        testIndicesByClass[d] = pool.slice(nTrain, nTrain + TEST_PER_CLASS);
    }
    shuffleArray(trainIndices);
}

// === Model ===
function buildModel() {
    const m = tf.sequential();
    m.add(tf.layers.dense({ inputShape: [IMAGE_SIZE], units: 128, activation: 'relu' }));
    m.add(tf.layers.dense({ units: 10, activation: 'softmax' }));
    m.compile({ optimizer: tf.train.adam(0.001), loss: 'categoricalCrossentropy', metrics: ['accuracy'] });
    return m;
}

// === Rendering ===
function renderMnistImage(canvas, imageIndex) {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.createImageData(28, 28);
    const offset = imageIndex * IMAGE_SIZE;
    for (let i = 0; i < IMAGE_SIZE; i++) {
        const v = Math.round(mnistData.images[offset + i] * 255);
        imageData.data[i * 4] = v;
        imageData.data[i * 4 + 1] = v;
        imageData.data[i * 4 + 2] = v;
        imageData.data[i * 4 + 3] = 255;
    }
    ctx.putImageData(imageData, 0, 0);
}

// === Prediction ===
function predictSingle(imageIndex) {
    return tf.tidy(() => {
        const pixels = mnistData.images.slice(imageIndex * IMAGE_SIZE, (imageIndex + 1) * IMAGE_SIZE);
        const input = tf.tensor2d([Array.from(pixels)]);
        const output = model.predict(input);
        const probs = Array.from(output.dataSync());
        const predicted = probs.indexOf(Math.max(...probs));
        return {
            label: predicted, confidence: probs[predicted],
            correct: predicted === mnistData.labels[imageIndex],
            trueLabel: mnistData.labels[imageIndex], imageIndex,
        };
    });
}

function predictBatch(indices) {
    return tf.tidy(() => {
        const n = indices.length;
        const batchData = new Float32Array(n * IMAGE_SIZE);
        indices.forEach((idx, i) => {
            batchData.set(mnistData.images.slice(idx * IMAGE_SIZE, (idx + 1) * IMAGE_SIZE), i * IMAGE_SIZE);
        });
        const input = tf.tensor2d(batchData, [n, IMAGE_SIZE]);
        const output = model.predict(input);
        const probs = output.arraySync();
        return indices.map((idx, i) => {
            const p = probs[i];
            const predicted = p.indexOf(Math.max(...p));
            return {
                label: predicted, confidence: p[predicted],
                correct: predicted === mnistData.labels[idx],
                trueLabel: mnistData.labels[idx], imageIndex: idx,
            };
        });
    });
}

// === UI: Distribution bars ===
function showDistributionBars() {
    const el = document.getElementById('distBars');
    let html = '';
    for (let d = 0; d < 10; d++) {
        const count = MAJORITY_CLASSES.has(d) ? MAJORITY_COUNT : MINORITY_COUNT;
        const pct = (count / MAJORITY_COUNT) * 100;
        const cls = MAJORITY_CLASSES.has(d) ? 'maj' : 'min';
        html += `<div class="dist-row">
            <span class="dist-digit">${d}</span>
            <div class="dist-bar-track"><div class="dist-bar-fill ${cls}" style="width:${pct}%"></div></div>
            <span class="dist-count">${count}</span>
        </div>`;
    }
    el.innerHTML = html;
}

// === UI: Class Buttons ===
function generateClassButtons() {
    const container = document.getElementById('classButtons');
    let html = '';
    for (let i = 0; i < 10; i++) {
        const cls = MAJORITY_CLASSES.has(i) ? 'maj' : 'min';
        html += `<button class="digit-btn ${cls}" onclick="analyzeClass(${i}, this)">${i}</button>`;
    }
    container.innerHTML = html;
}

// === UI: Training ===
async function startTraining() {
    document.getElementById('trainButton').disabled = true;
    document.getElementById('trainingProgress').style.display = 'block';
    document.getElementById('trainingResult').innerHTML = '';

    if (model) model.dispose();
    model = buildModel();

    const trainPixels = new Float32Array(trainIndices.length * IMAGE_SIZE);
    const trainLabelsArr = new Int32Array(trainIndices.length);
    trainIndices.forEach((idx, i) => {
        trainPixels.set(mnistData.images.slice(idx * IMAGE_SIZE, (idx + 1) * IMAGE_SIZE), i * IMAGE_SIZE);
        trainLabelsArr[i] = mnistData.labels[idx];
    });
    const xs = tf.tensor2d(trainPixels, [trainIndices.length, IMAGE_SIZE]);
    const ys = tf.oneHot(tf.tensor1d(trainLabelsArr, 'int32'), NUM_CLASSES);

    await model.fit(xs, ys, {
        epochs: TRAIN_EPOCHS, batchSize: 32, shuffle: true,
        callbacks: {
            onEpochEnd: (epoch, logs) => {
                const pct = ((epoch + 1) / TRAIN_EPOCHS * 100);
                document.getElementById('epochBarFill').style.width = pct + '%';
                finalTrainAcc = logs.acc;
                document.getElementById('epochInfo').textContent =
                    `Epoch ${epoch + 1}/${TRAIN_EPOCHS}  loss=${logs.loss.toFixed(3)}  acc=${(logs.acc * 100).toFixed(1)}%`;
            }
        }
    });
    xs.dispose(); ys.dispose();

    networkTrained = true;
    document.getElementById('testButton').disabled = false;
    document.getElementById('trainingResult').innerHTML =
        `<div class="status ok" style="margin-top:10px;">Training complete</div>`;
    document.getElementById('totalAccuracy').textContent = `${(finalTrainAcc * 100).toFixed(1)}%`;
}

// === UI: Test Random Image ===
function testRandomImage() {
    if (!networkTrained) return;
    document.getElementById('placeholderCard').style.display = 'none';
    document.getElementById('testResultCard').style.display = '';

    const randomClass = Math.floor(Math.random() * 10);
    const classIndices = testIndicesByClass[randomClass];
    const randomIdx = classIndices[Math.floor(Math.random() * classIndices.length)];
    const pred = predictSingle(randomIdx);
    const isMaj = MAJORITY_CLASSES.has(randomClass);

    const testDiv = document.getElementById('individualTest');
    testDiv.innerHTML = `
        <div class="test-result">
            <div class="test-image-wrap">
                <canvas id="testCanvas" class="mnist-canvas mnist-canvas-lg" width="28" height="28"></canvas>
            </div>
            <div class="test-info">
                <div class="row"><span class="label">True label</span><span class="val">${randomClass} <span style="font-weight:400;color:${isMaj ? 'var(--good)' : 'var(--bad)'}; font-size:11px;">${isMaj ? 'majority' : 'minority'}</span></span></div>
                <div class="row"><span class="label">Predicted</span><span class="val ${pred.correct ? 'correct' : 'wrong'}">${pred.label}</span></div>
                <div class="row"><span class="label">Confidence</span><span class="val">${(pred.confidence * 100).toFixed(1)}%</span></div>
                <div class="row"><span class="label">Result</span><span class="val ${pred.correct ? 'correct' : 'wrong'}">${pred.correct ? 'Correct' : 'Wrong'}</span></div>
                <div class="conf-track"><div class="conf-fill" style="width:${pred.confidence*100}%;background:${pred.correct ? 'var(--good)' : 'var(--bad)'}"></div></div>
                ${!pred.correct && !isMaj ? '<div style="font-size:11px;color:var(--ink-light);margin-top:8px;">Minority class misclassified as majority — a signature of label shift.</div>' : ''}
            </div>
        </div>
    `;
    renderMnistImage(document.getElementById('testCanvas'), randomIdx);
}

// === UI: Analyze Class ===
function analyzeClass(digitClass, buttonEl) {
    if (!networkTrained) return;
    document.querySelectorAll('.digit-btn').forEach(btn => btn.classList.remove('active'));
    buttonEl.classList.add('active');

    document.getElementById('placeholderCard').style.display = 'none';
    document.getElementById('analysisCard').style.display = '';
    document.getElementById('analysisTitle').textContent = `Class ${digitClass} — ${MAJORITY_CLASSES.has(digitClass) ? 'Majority' : 'Minority'}`;

    const analysisDiv = document.getElementById('classAnalysis');
    analysisDiv.innerHTML = '<div class="status loading">Evaluating 100 test images…</div>';

    requestAnimationFrame(() => {
        const indices = testIndicesByClass[digitClass];
        const predictions = predictBatch(indices);
        const predictionCounts = Array(10).fill(0);
        let correctCount = 0;
        predictions.forEach(p => { predictionCounts[p.label]++; if (p.correct) correctCount++; });

        const accuracy = correctCount / indices.length;
        const isMaj = MAJORITY_CLASSES.has(digitClass);
        classResults[digitClass] = { accuracy, predictionCounts, isMajority: isMaj };

        // Mark button as evaluated
        buttonEl.classList.add('evaluated');

        const samples = predictions.slice(0, 12);
        let samplesHTML = '<div class="sample-row">';
        samples.forEach((pred, i) => {
            samplesHTML += `
                <div class="sample-item ${pred.correct ? '' : 'wrong'}">
                    <canvas id="smp_${digitClass}_${i}" width="28" height="28"></canvas>
                    <div class="tag ${pred.correct ? 'ok' : 'fail'}">${pred.correct ? 'ok' : '→'+pred.label}</div>
                </div>`;
        });
        samplesHTML += '</div>';

        analysisDiv.innerHTML = `
            <div class="analysis-header">
                <div class="analysis-acc" style="color:${accuracy > 0.7 ? 'var(--good)' : 'var(--bad)'}">
                    ${(accuracy * 100).toFixed(0)}%
                </div>
                <div class="analysis-meta">
                    ${correctCount}/100 correct<br>
                    ${isMaj ? 'Well-represented in training (300 samples)' : 'Under-represented in training (14 samples)'}
                </div>
            </div>
            ${samplesHTML}
            <div class="chart-wrap"><canvas id="histogram_${digitClass}"></canvas></div>
        `;

        samples.forEach((pred, i) => {
            renderMnistImage(document.getElementById(`smp_${digitClass}_${i}`), pred.imageIndex);
        });

        const hctx = document.getElementById(`histogram_${digitClass}`).getContext('2d');
        new Chart(hctx, {
            type: 'bar',
            data: {
                labels: ['0','1','2','3','4','5','6','7','8','9'],
                datasets: [{
                    data: predictionCounts,
                    backgroundColor: predictionCounts.map((_, i) =>
                        i === digitClass ? 'rgba(26,122,58,0.7)' :
                        MAJORITY_CLASSES.has(i) ? 'rgba(192,48,48,0.5)' : 'rgba(180,175,165,0.4)'
                    ),
                    borderColor: predictionCounts.map((_, i) =>
                        i === digitClass ? '#1a7a3a' :
                        MAJORITY_CLASSES.has(i) ? '#c03030' : '#b4afa5'
                    ),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false, animation: false,
                plugins: {
                    legend: { display: false },
                    title: { display: true, text: `Predictions for true digit ${digitClass}`,
                        font: { family: 'IBM Plex Mono', size: 11, weight: '500' }, color: '#6b6b6b' }
                },
                scales: {
                    y: { beginAtZero: true, grid: { color: '#e8e5de' },
                        ticks: { font: { family: 'IBM Plex Mono', size: 10 }, color: '#a3a3a3' } },
                    x: { grid: { display: false },
                        ticks: { font: { family: 'IBM Plex Mono', size: 11 }, color: '#1a1a1a' } }
                }
            }
        });
        updateMetrics();
        checkShiftButton();
    });
}

// === UI: Metrics ===
function updateMetrics() {
    const analyzed = Object.keys(classResults).map(Number);
    const majR = analyzed.filter(d => MAJORITY_CLASSES.has(d));
    const minR = analyzed.filter(d => !MAJORITY_CLASSES.has(d));
    if (majR.length > 0) {
        const avg = majR.reduce((s, d) => s + classResults[d].accuracy, 0) / majR.length;
        document.getElementById('majorityAcc').textContent = `${(avg * 100).toFixed(1)}%`;
    }
    if (minR.length > 0) {
        const avg = minR.reduce((s, d) => s + classResults[d].accuracy, 0) / minR.length;
        document.getElementById('minorityAcc').textContent = `${(avg * 100).toFixed(1)}%`;
    }
    if (majR.length > 0 && minR.length > 0) {
        const avgMaj = majR.reduce((s, d) => s + classResults[d].accuracy, 0) / majR.length;
        const avgMin = minR.reduce((s, d) => s + classResults[d].accuracy, 0) / minR.length;
        document.getElementById('accGap').textContent = `${((avgMaj - avgMin) * 100).toFixed(1)}%`;
    }
}

function checkShiftButton() {
    const analyzed = Object.keys(classResults).map(Number);
    const hasMaj = analyzed.some(d => MAJORITY_CLASSES.has(d));
    const hasMin = analyzed.some(d => !MAJORITY_CLASSES.has(d));
    document.getElementById('shiftButton').disabled = !(hasMaj && hasMin);
}

// === UI: Label Shift Summary ===
function showLabelShiftSummary() {
    document.getElementById('placeholderCard').style.display = 'none';
    document.getElementById('summaryCard').style.display = '';

    document.getElementById('shiftAnalysis').innerHTML = `
        <div class="insight-box">
            <strong>P(Y) changed between train and test.</strong>
            <ul>
                <li>Train: P(Y=0) = P(Y=3) = P(Y=9) = 30% each, others ~1.4%</li>
                <li>Test: P(Y=k) = 10% for all k</li>
                <li>P(X|Y) is unchanged — a "3" still looks like a "3"</li>
                <li>But the model learned a strong prior toward majority classes</li>
            </ul>
        </div>
        <div class="insight-box" style="border-left-color: var(--good);">
            <strong>Fixes:</strong> rebalance training data, use class weights in loss, or apply prior correction at test time.
        </div>
    `;
}

// === Reset ===
function resetDemo() {
    if (model) { model.dispose(); model = null; }
    networkTrained = false;
    finalTrainAcc = 0;
    classResults = {};
    createDatasets();

    document.getElementById('trainButton').disabled = false;
    document.getElementById('testButton').disabled = true;
    document.getElementById('shiftButton').disabled = true;
    document.getElementById('trainingProgress').style.display = 'none';
    document.getElementById('trainingResult').innerHTML = '';
    document.getElementById('epochBarFill').style.width = '0%';
    document.getElementById('epochInfo').textContent = '';

    document.getElementById('testResultCard').style.display = 'none';
    document.getElementById('analysisCard').style.display = 'none';
    document.getElementById('summaryCard').style.display = 'none';
    document.getElementById('placeholderCard').style.display = '';

    document.querySelectorAll('.digit-btn').forEach(btn => {
        btn.classList.remove('active', 'evaluated');
    });
    document.getElementById('totalAccuracy').textContent = '—';
    document.getElementById('majorityAcc').textContent = '—';
    document.getElementById('minorityAcc').textContent = '—';
    document.getElementById('accGap').textContent = '—';
}

// === Init ===
window.addEventListener('load', async () => {
    generateClassButtons();
    try {
        mnistData = await loadMnistData();
        createDatasets();
        document.getElementById('dataStatus').className = 'status ok';
        document.getElementById('dataStatus').textContent = `MNIST loaded — ${NUM_DATASET_ELEMENTS.toLocaleString()} images`;
        document.getElementById('trainSection').style.display = '';
        showDistributionBars();
    } catch (e) {
        document.getElementById('dataStatus').className = 'status err';
        document.getElementById('dataStatus').textContent = `Error: ${e.message}`;
    }
});
</script>
</body>
</html>
