<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Ridge Regression: Effect of λ</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 15px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #fafafa;
        }
        .top-bar {
            margin-bottom: 10px;
        }
        .container {
            display: flex;
            gap: 15px;
            height: calc(100vh - 120px);
        }
        .panel {
            flex: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 10px;
            display: flex;
            flex-direction: column;
        }
        .panel h3 {
            margin: 0 0 5px 0;
            font-size: 22px;
            color: #333;
        }
        .panel .subtitle {
            font-size: 18px;
            color: #666;
            margin-bottom: 5px;
            line-height: 1.4;
        }
        .plot {
            flex: 1;
        }
        .slider-container {
            display: flex;
            gap: 20px;
            align-items: center;
            padding: 10px 15px;
            background: #f0f0f0;
            border-radius: 8px;
        }
        .slider-col {
            flex: 1;
        }
        .slider-label {
            font-size: 22px;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .slider-label .hint {
            font-size: 14px;
            color: #999;
        }
        .slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, #b4a7d6, #674ea7);
            border-radius: 3px;
            outline: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #674ea7;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #674ea7;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border: none;
        }
        .theta-val {
            color: #674ea7;
        }
        .j-val {
            color: #cc8800;
        }
        .norm-val {
            color: #3c78d8;
        }
        .col-vec {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            padding: 0 6px;
            margin: 0 9px;
            line-height: 1.2;
            font-size: 22px;
            position: relative;
        }
        .col-vec::before {
            content: '[';
            position: absolute;
            left: -12px;
            top: 50%;
            transform: translateY(-50%) scaleY(2.2);
            font-size: 24px;
        }
        .col-vec::after {
            content: ']';
            position: absolute;
            right: -12px;
            top: 50%;
            transform: translateY(-50%) scaleY(2.2);
            font-size: 24px;
        }
        .matrix {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            padding: 2px 8px;
            margin: 0 14px;
            line-height: 1.3;
            font-size: 20px;
            position: relative;
        }
        .matrix::before {
            content: '[';
            position: absolute;
            left: -14px;
            top: 50%;
            transform: translateY(-50%) scaleY(3.5);
            font-size: 24px;
        }
        .matrix::after {
            content: ']';
            position: absolute;
            right: -14px;
            top: 50%;
            transform: translateY(-50%) scaleY(3.5);
            font-size: 24px;
        }
        .matrix-row {
            display: flex;
            gap: 12px;
        }
        .matrix-row span {
            min-width: 28px;
            text-align: right;
        }
        .legend-swatch {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 3px;
            vertical-align: middle;
            margin-right: 4px;
        }

        .tick-marks {
            display: flex;
            justify-content: space-between;
            padding: 2px 0 0 0;
            position: relative;
        }
        .tick-marks span {
            font-size: 11px;
            color: #999;
            text-align: center;
            width: 0;
            overflow: visible;
            white-space: nowrap;
        }
        .tick-marks span:first-child { text-align: left; }
        .tick-marks span:last-child { text-align: right; }

        /* Embed mode */
        body.embed {
            overflow: hidden;
        }
        body.embed .container {
            height: calc(100vh - 130px);
        }

        /* Jonly mode: show only the objective surface */
        body.Jonly .top-bar {
            display: none;
        }
        body.Jonly .container {
            height: 100vh;
        }
        body.Jonly .panel:first-child {
            display: none;
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <div class="slider-container">
            <div class="slider-col">
                <div class="slider-label">
                    <span class="hint">← OLS</span>
                    <span>λ = <span id="lambda-val">0.0</span></span>
                    <span class="hint">θ magnitude penalty dominates →</span>
                </div>
                <input type="range" id="lambda-slider" class="slider" min="0" max="1000" step="1" value="0">
                <div class="tick-marks">
                    <span>0</span>
                    <span>10⁻¹⁰</span>
                    <span>⁻⁸</span>
                    <span>⁻⁶</span>
                    <span>⁻⁴</span>
                    <span>⁻²</span>
                    <span>10⁰</span>
                    <span>10¹</span>
                </div>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="panel">
            <h3>Data &amp; Hypothesis</h3>
            <div class="subtitle">
                <span style="color: #3c78d8; display: inline-flex; align-items: center; gap: 8px;">
                    X = <span class="matrix"><span class="matrix-row"><span>−2</span><span>−4.00006</span></span><span class="matrix-row"><span>−1</span><span>−2.00004</span></span><span class="matrix-row"><span>1</span><span>2.00004</span></span><span class="matrix-row"><span>2</span><span>4.00006</span></span></span>
                    &nbsp; Y = <span class="matrix"><span class="matrix-row"><span>−1.8</span></span><span class="matrix-row"><span>−1.2</span></span><span class="matrix-row"><span>1.2</span></span><span class="matrix-row"><span>1.8</span></span></span>
                </span>
                <br><span id="hypothesis-text" style="color: #674ea7; font-size: 22px;">h = 0.549 x₁ + 0.824 x₂</span>
            </div>
            <div id="data-plot" class="plot"></div>
        </div>
        <div class="panel">
            <h3>Objective in θ-space</h3>
            <div class="subtitle">
                <span class="legend-swatch" style="background: #bbb;"></span>MSE &nbsp;
                <span class="legend-swatch" style="background: #ffd966;"></span>Ridge (MSE + λ‖θ‖²) &nbsp;
                <span style="color: #3c78d8;">◆</span> θ*<sub>ridge</sub>
                <br><span id="obj-stats" style="color: #666; font-size: 22px;"><span class="norm-val">‖θ*‖ = 0.990</span> &nbsp; <span class="j-val">MSE = 5.14</span></span>
            </div>
            <div id="obj-plot" class="plot"></div>
        </div>
    </div>

    <script>
        // Detect embed mode
        const params = new URLSearchParams(window.location.search);
        if (params.has('embed')) {
            document.body.classList.add('embed');
        }
        if (params.has('Jonly')) {
            document.body.classList.add('Jonly');
        }

        // Super sensitive: x2 ≈ 2*x1 with ~0.00004 perturbation → det(X^TX) ≈ 1.6e-9
        const dataPoints = [
            { x1: -2, x2: -4.00006, y: -1.8 },
            { x1: -1, x2: -2.00004, y: -1.2 },
            { x1:  1, x2:  2.00004, y:  1.2 },
            { x1:  2, x2:  4.00006, y:  1.8 }
        ];
        const n = dataPoints.length;

        // MSE loss function
        function mse(t1, t2) {
            let sum = 0;
            for (const pt of dataPoints) {
                sum += Math.pow(t1 * pt.x1 + t2 * pt.x2 - pt.y, 2);
            }
            return sum / n;
        }

        // Ridge cost = MSE + lambda * ||theta||^2
        function ridgeCost(t1, t2, lambda) {
            return mse(t1, t2) + lambda * (t1 * t1 + t2 * t2);
        }

        // Solve ridge analytically: theta* = (X^TX + n*lambda*I)^{-1} X^T Y
        function solveRidge(lambda) {
            const lam = Math.max(lambda, 1e-10);
            let a11 = 0, a12 = 0, a22 = 0, b1 = 0, b2 = 0;
            for (const pt of dataPoints) {
                a11 += pt.x1 * pt.x1;
                a12 += pt.x1 * pt.x2;
                a22 += pt.x2 * pt.x2;
                b1 += pt.x1 * pt.y;
                b2 += pt.x2 * pt.y;
            }
            a11 += n * lam;
            a22 += n * lam;
            const det = a11 * a22 - a12 * a12;
            return {
                t1: (a22 * b1 - a12 * b2) / det,
                t2: (a11 * b2 - a12 * b1) / det
            };
        }

        // ==================== Precompute grids ====================
        const gridSize = 50;
        const tMin = -5, tMax = 5;
        const t1Range = [], t2Range = [];
        for (let i = 0; i <= gridSize; i++) {
            t1Range.push(tMin + i * (tMax - tMin) / gridSize);
            t2Range.push(tMin + i * (tMax - tMin) / gridSize);
        }

        const mseGrid = [];
        const penaltyGrid = [];
        for (let j = 0; j <= gridSize; j++) {
            const mseRow = [], penRow = [];
            for (let i = 0; i <= gridSize; i++) {
                mseRow.push(mse(t1Range[i], t2Range[j]));
                penRow.push(t1Range[i] * t1Range[i] + t2Range[j] * t2Range[j]);
            }
            mseGrid.push(mseRow);
            penaltyGrid.push(penRow);
        }

        // Fixed z-axis range based on MSE so grey surface never rescales
        let maxMSE = 0;
        for (const row of mseGrid) {
            for (const v of row) {
                if (v > maxMSE) maxMSE = v;
            }
        }

        // ==================== Common styling ====================
        const axisStyle = {
            titlefont: { size: 16, family: 'Arial Bold, Arial', color: '#333' },
            tickfont: { size: 11, color: '#999' },
            nticks: 5,
            gridcolor: '#ddd'
        };

        // ==================== Data Plot (Left) ====================
        const initMin = solveRidge(0);
        let theta1 = initMin.t1;
        let theta2 = initMin.t2;

        function createDataPlot() {
            const pGridSize = 10;
            const px1 = [], px2 = [];
            for (let i = 0; i <= pGridSize; i++) {
                px1.push(-3 + i * 6 / pGridSize);
                px2.push(-5 + i * 10 / pGridSize);
            }

            const planeZ = [];
            for (let j = 0; j < px2.length; j++) {
                const row = [];
                for (let i = 0; i < px1.length; i++) {
                    row.push(theta1 * px1[i] + theta2 * px2[j]);
                }
                planeZ.push(row);
            }

            const plane = {
                type: 'surface',
                x: px1,
                y: px2,
                z: planeZ,
                colorscale: [[0, '#b4a7d6'], [1, '#674ea7']],
                opacity: 0.7,
                showscale: false,
                hoverinfo: 'skip'
            };

            const traces = [plane];

            // Deviation lines and data points
            for (const pt of dataPoints) {
                const prediction = theta1 * pt.x1 + theta2 * pt.x2;

                // Vertical deviation line
                traces.push({
                    type: 'scatter3d',
                    mode: 'lines',
                    x: [pt.x1, pt.x1],
                    y: [pt.x2, pt.x2],
                    z: [prediction, pt.y],
                    line: { color: '#674ea7', width: 5, dash: 'dash' },
                    hoverinfo: 'skip'
                });

                // Point on plane
                traces.push({
                    type: 'scatter3d',
                    mode: 'markers',
                    x: [pt.x1],
                    y: [pt.x2],
                    z: [prediction],
                    marker: { size: 6, color: '#674ea7', symbol: 'diamond' },
                    hoverinfo: 'skip'
                });

                // Actual data point
                traces.push({
                    type: 'scatter3d',
                    mode: 'markers',
                    x: [pt.x1],
                    y: [pt.x2],
                    z: [pt.y],
                    marker: { size: 10, color: '#3c78d8', line: { color: '#1a4a8a', width: 2 } },
                    hoverinfo: 'skip'
                });
            }

            return traces;
        }

        const dataLayout = {
            scene: {
                xaxis: { title: 'x₁', range: [-3, 3], ...axisStyle },
                yaxis: { title: 'x₂', range: [-5, 5], ...axisStyle },
                zaxis: { title: 'y', range: [-3, 3], ...axisStyle },
                camera: { eye: { x: 1.29, y: 1.60, z: 1.81 } },
                aspectmode: 'cube'
            },
            margin: { l: 0, r: 0, t: 0, b: 0 },
            showlegend: false
        };

        Plotly.newPlot('data-plot', createDataPlot(), dataLayout, {
            responsive: true,
            displayModeBar: false
        });

        // ==================== Objective Plot (Right) ====================
        // MSE surface (grey, fixed)
        const mseSurface = {
            type: 'surface',
            x: t1Range,
            y: t2Range,
            z: mseGrid,
            colorscale: [[0, '#e0e0e0'], [1, '#999999']],
            opacity: 0.5,
            showscale: false,
            hoverinfo: 'skip'
        };

        // Ridge surface (yellow, varies with lambda)
        const ridgeSurface = {
            type: 'surface',
            x: t1Range,
            y: t2Range,
            z: getRidgeGrid(0),
            colorscale: [[0, '#fff2cc'], [0.3, '#ffd966'], [1, '#f6b26b']],
            opacity: 0.7,
            showscale: false,
            hoverinfo: 'skip'
        };

        // Origin marker lines (θ₁=0 and θ₂=0 axes on the floor)
        const originLineT1 = {
            type: 'scatter3d',
            mode: 'lines',
            x: [0, 0],
            y: [tMin, tMax],
            z: [0, 0],
            line: { color: '#333', width: 3 },
            hoverinfo: 'skip'
        };
        const originLineT2 = {
            type: 'scatter3d',
            mode: 'lines',
            x: [tMin, tMax],
            y: [0, 0],
            z: [0, 0],
            line: { color: '#333', width: 3 },
            hoverinfo: 'skip'
        };
        const originDot = {
            type: 'scatter3d',
            mode: 'markers',
            x: [0],
            y: [0],
            z: [0],
            marker: { size: 6, color: '#333', symbol: 'circle' },
            hoverinfo: 'skip'
        };

        // Ridge minimum marker
        const ridgeMinMarker = {
            type: 'scatter3d',
            mode: 'markers',
            x: [initMin.t1],
            y: [initMin.t2],
            z: [ridgeCost(initMin.t1, initMin.t2, 0) + 0.5],
            marker: { size: 10, color: '#3c78d8', symbol: 'diamond' },
            hoverinfo: 'skip'
        };

        function getRidgeGrid(lambda) {
            const grid = [];
            for (let j = 0; j <= gridSize; j++) {
                const row = [];
                for (let i = 0; i <= gridSize; i++) {
                    row.push(mseGrid[j][i] + lambda * penaltyGrid[j][i]);
                }
                grid.push(row);
            }
            return grid;
        }

        const objCameraAngle = { eye: { x: 2.40, y: -0.01, z: 0.59 } };

        const objLayout = {
            scene: {
                xaxis: { title: 'θ₁', range: [tMin, tMax], ...axisStyle },
                yaxis: { title: 'θ₂', range: [tMin, tMax], ...axisStyle },
                zaxis: { title: 'J(θ)', range: [0, maxMSE], ...axisStyle },
                camera: objCameraAngle,
                aspectmode: 'cube'
            },
            margin: { l: 0, r: 0, t: 0, b: 0 },
            showlegend: false
        };

        // Traces: 0=MSE(grey), 1=originT1, 2=originT2, 3=originDot, 4=Ridge(yellow), 5=minimum marker
        Plotly.newPlot('obj-plot', [mseSurface, originLineT1, originLineT2, originDot, ridgeSurface, ridgeMinMarker], objLayout, {
            responsive: true,
            displayModeBar: false
        });

        // ==================== Slider interaction ====================
        const lambdaSlider = document.getElementById('lambda-slider');

        // Log-scale mapping: slider 0 → λ=0, slider 1..1000 → λ = 10^-10..10^1
        function sliderToLambda(p) {
            if (p === 0) return 0;
            return Math.pow(10, -10 + 11 * p / 1000);
        }

        function update() {
            const p = parseFloat(lambdaSlider.value);
            const lambda = sliderToLambda(p);
            document.getElementById('lambda-val').textContent = lambda === 0 ? '0' : lambda < 0.01 ? lambda.toExponential(1) : lambda.toFixed(2);

            // Solve for ridge minimum
            const min = solveRidge(lambda);
            theta1 = min.t1;
            theta2 = min.t2;
            const jMse = mse(theta1, theta2);
            const norm = Math.sqrt(theta1 * theta1 + theta2 * theta2);
            const jRidge = jMse + lambda * (theta1 * theta1 + theta2 * theta2);

            // Update left panel: hypothesis annotation
            document.getElementById('hypothesis-text').textContent =
                `h = ${theta1.toFixed(3)} x₁ + ${theta2.toFixed(3)} x₂`;

            // Update right panel: norm and MSE
            document.getElementById('obj-stats').innerHTML =
                `<span class="norm-val">‖θ*‖ = ${norm.toFixed(3)}</span> &nbsp; ` +
                `<span class="j-val">MSE = ${jMse.toFixed(2)}</span>`;

            // Update data plot: hypothesis plane changes with theta
            Plotly.react('data-plot', createDataPlot(), dataLayout);

            // Update objective plot: ridge surface + minimum marker
            const ridgeGrid = getRidgeGrid(lambda);
            Plotly.restyle('obj-plot', { z: [ridgeGrid] }, 4);  // trace 4 = ridge surface
            Plotly.restyle('obj-plot', {
                x: [[theta1]],
                y: [[theta2]],
                z: [[jRidge + 0.5]]
            }, 5);  // trace 5 = minimum marker
        }

        lambdaSlider.addEventListener('input', update);
        update();
    </script>
</body>
</html>
