<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Convexity of ML Objectives</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 15px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #fafafa;
        }
        .top-bar {
            margin-bottom: 10px;
        }
        .controls {
            display: flex;
            gap: 16px;
            align-items: center;
            padding: 10px 15px;
            background: #f0f0f0;
            border-radius: 8px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .control-group label {
            font-size: 15px;
            color: #333;
            white-space: nowrap;
        }
        .separator {
            width: 1px;
            height: 28px;
            background: #ccc;
        }
        .slider {
            width: 100px;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            border-radius: 3px;
            outline: none;
        }
        .slider.purple {
            background: linear-gradient(to right, #b4a7d6, #674ea7);
        }
        .slider.blue {
            background: linear-gradient(to right, #a4c2f4, #3c78d8);
        }
        .slider.green {
            background: linear-gradient(to right, #b6d7a8, #38761d);
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #444;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #444;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            border: none;
        }
        .plot-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 10px;
            height: calc(100vh - 100px);
        }
        #plot { width: 100%; height: 100%; }
        .point-a { color: #3c78d8; font-weight: 600; }
        .point-b { color: #38761d; font-weight: 600; }

        /* Embed mode */
        body.embed {
            overflow: hidden;
        }
        body.embed .plot-container {
            height: calc(100vh - 90px);
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <div class="controls">
            <div class="control-group">
                <label>λ = <span id="lambda-val">0.0</span></label>
                <input type="range" id="lambda-slider" class="slider purple" min="0" max="100" step="1" value="0">
            </div>
            <div class="separator"></div>
            <div class="control-group">
                <label class="point-a">A:</label>
                <label>θ₁</label>
                <input type="range" id="a1-slider" class="slider blue" min="0" max="1000" step="1" value="250">
                <label>θ₂</label>
                <input type="range" id="a2-slider" class="slider blue" min="0" max="1000" step="1" value="250">
            </div>
            <div class="separator"></div>
            <div class="control-group">
                <label class="point-b">B:</label>
                <label>θ₁</label>
                <input type="range" id="b1-slider" class="slider green" min="0" max="1000" step="1" value="750">
                <label>θ₂</label>
                <input type="range" id="b2-slider" class="slider green" min="0" max="1000" step="1" value="688">
            </div>
        </div>
    </div>
    <div class="plot-container">
        <div id="plot"></div>
    </div>

    <script>
        const params = new URLSearchParams(window.location.search);
        if (params.has('embed')) document.body.classList.add('embed');

        // ==================== Loss function ====================
        // Same data as d2-unique-solution: (1,0)->2, (0,1)->3, (1,1)->5
        const data = [
            { x1: 1, x2: 0, y: 2 },
            { x1: 0, x2: 1, y: 3 },
            { x1: 1, x2: 1, y: 5 }
        ];
        const n = data.length;

        function jMSE(t1, t2) {
            let sum = 0;
            for (const d of data) sum += (t1 * d.x1 + t2 * d.x2 - d.y) ** 2;
            return sum / n;
        }

        function jRidge(t1, t2, lambda) {
            return jMSE(t1, t2) + lambda * (t1 * t1 + t2 * t2);
        }

        // ==================== Surface grid ====================
        const gridSize = 50;
        const t1Min = -1, t1Max = 5, t2Min = -1, t2Max = 7;
        const t1Range = [], t2Range = [];
        for (let i = 0; i <= gridSize; i++) {
            t1Range.push(t1Min + i * (t1Max - t1Min) / gridSize);
            t2Range.push(t2Min + i * (t2Max - t2Min) / gridSize);
        }

        function getSurfaceGrid(lambda) {
            const grid = [];
            for (let j = 0; j <= gridSize; j++) {
                const row = [];
                for (let i = 0; i <= gridSize; i++) {
                    row.push(jRidge(t1Range[i], t2Range[j], lambda));
                }
                grid.push(row);
            }
            return grid;
        }

        // ==================== Slider mapping ====================
        function sliderToT1(val) { return t1Min + (val / 1000) * (t1Max - t1Min); }
        function sliderToT2(val) { return t2Min + (val / 1000) * (t2Max - t2Min); }

        // ==================== Plotting ====================
        const axisStyle = {
            titlefont: { size: 16, family: 'Arial Bold, Arial', color: '#333' },
            tickfont: { size: 11, color: '#999' },
            nticks: 5,
            gridcolor: '#ddd'
        };

        const nSeg = 30;  // number of sample points along chord

        function plot() {
            const lambdaRaw = parseFloat(document.getElementById('lambda-slider').value);
            const lambda = lambdaRaw / 20;  // 0 to 5
            document.getElementById('lambda-val').textContent = lambda.toFixed(1);

            const a1 = sliderToT1(document.getElementById('a1-slider').value);
            const a2 = sliderToT2(document.getElementById('a2-slider').value);
            const b1 = sliderToT1(document.getElementById('b1-slider').value);
            const b2 = sliderToT2(document.getElementById('b2-slider').value);

            const fn = (t1, t2) => jRidge(t1, t2, lambda);
            const jA = fn(a1, a2);
            const jB = fn(b1, b2);

            // Surface
            const surface = {
                type: 'surface',
                x: t1Range,
                y: t2Range,
                z: getSurfaceGrid(lambda),
                colorscale: [[0, '#ffd966'], [0.3, '#f6b26b'], [1, '#cc4125']],
                opacity: 0.75,
                showscale: false,
                hoverinfo: 'skip'
            };

            // Chord: straight line from A to B
            const chordX = [], chordY = [], chordZ = [];
            for (let i = 0; i <= nSeg; i++) {
                const t = i / nSeg;
                chordX.push(a1 + t * (b1 - a1));
                chordY.push(a2 + t * (b2 - a2));
                chordZ.push(jA + t * (jB - jA));
            }

            const chord = {
                type: 'scatter3d',
                mode: 'lines',
                x: chordX, y: chordY, z: chordZ,
                line: { color: '#674ea7', width: 6, dash: 'dash' },
                hoverinfo: 'skip'
            };

            // Surface path: actual J values along the same θ trajectory
            const pathX = [], pathY = [], pathZ = [];
            for (let i = 0; i <= nSeg; i++) {
                const t = i / nSeg;
                const pt1 = a1 + t * (b1 - a1);
                const pt2 = a2 + t * (b2 - a2);
                pathX.push(pt1);
                pathY.push(pt2);
                pathZ.push(fn(pt1, pt2));
            }

            const surfacePath = {
                type: 'scatter3d',
                mode: 'lines',
                x: pathX, y: pathY, z: pathZ,
                line: { color: '#cc8800', width: 4 },
                hoverinfo: 'skip'
            };

            // Vertical gap lines: from chord down to surface
            const traces = [surface, surfacePath, chord];

            for (let i = 1; i < nSeg; i += 2) {
                const t = i / nSeg;
                const pt1 = a1 + t * (b1 - a1);
                const pt2 = a2 + t * (b2 - a2);
                const chordVal = jA + t * (jB - jA);
                const surfVal = fn(pt1, pt2);

                traces.push({
                    type: 'scatter3d',
                    mode: 'lines',
                    x: [pt1, pt1],
                    y: [pt2, pt2],
                    z: [chordVal, surfVal],
                    line: { color: 'rgba(103, 78, 167, 0.4)', width: 2 },
                    hoverinfo: 'skip'
                });
            }

            // Point A
            traces.push({
                type: 'scatter3d',
                mode: 'markers',
                x: [a1], y: [a2], z: [jA],
                marker: { size: 10, color: '#3c78d8', symbol: 'diamond',
                          line: { color: '#1a4a8a', width: 1 } },
                hoverinfo: 'skip'
            });

            // Point B
            traces.push({
                type: 'scatter3d',
                mode: 'markers',
                x: [b1], y: [b2], z: [jB],
                marker: { size: 10, color: '#38761d', symbol: 'diamond',
                          line: { color: '#1a4a3a', width: 1 } },
                hoverinfo: 'skip'
            });

            const titleText = lambda > 0
                ? `J<sub>ridge</sub>(θ) with λ=${lambda.toFixed(1)} — chord ≥ surface everywhere`
                : 'J<sub>MSE</sub>(θ) — chord ≥ surface everywhere';

            const layout = {
                title: { text: titleText, font: { size: 16 }, y: 0.98 },
                scene: {
                    xaxis: { title: 'θ₁', range: [t1Min, t1Max], ...axisStyle },
                    yaxis: { title: 'θ₂', range: [t2Min, t2Max], ...axisStyle },
                    zaxis: { title: 'J(θ)', ...axisStyle },
                    camera: { eye: { x: 1.8, y: -1.8, z: 0.8 } },
                    aspectmode: 'cube'
                },
                margin: { l: 0, r: 0, t: 35, b: 0 },
                showlegend: false
            };

            Plotly.react('plot', traces, layout, {
                responsive: true,
                displayModeBar: false
            });
        }

        // Event listeners
        const sliders = ['lambda-slider', 'a1-slider', 'a2-slider', 'b1-slider', 'b2-slider'];
        for (const id of sliders) {
            document.getElementById(id).addEventListener('input', plot);
        }

        plot();
    </script>
</body>
</html>
