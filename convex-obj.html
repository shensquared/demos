<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Convexity of ML Objectives</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 15px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #fafafa;
        }
        .top-bar {
            margin-bottom: 10px;
        }
        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
            padding: 10px 15px;
            background: #f0f0f0;
            border-radius: 8px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            font-size: 16px;
            color: #333;
            white-space: nowrap;
        }
        select {
            font-size: 16px;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .slider {
            width: 140px;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, #b4a7d6, #674ea7);
            border-radius: 3px;
            outline: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #674ea7;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #674ea7;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border: none;
        }
        .plot-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 10px;
            height: calc(100vh - 100px);
        }
        #plot { width: 100%; height: 100%; }
        .lambda-control {
            transition: opacity 0.3s;
        }
        .lambda-control.hidden {
            opacity: 0.3;
            pointer-events: none;
        }

        /* Embed mode */
        body.embed {
            overflow: hidden;
        }
        body.embed .plot-container {
            height: calc(100vh - 90px);
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <div class="controls">
            <div class="control-group">
                <select id="fn-select">
                    <option value="mse">J_MSE(θ) — convex</option>
                    <option value="nonconvex">non-convex objective</option>
                </select>
            </div>
            <div class="control-group lambda-control" id="lambda-group">
                <label>+ λθ², λ = <span id="lambda-val">0.0</span></label>
                <input type="range" id="lambda-slider" class="slider" min="0" max="100" step="1" value="0">
            </div>
            <div class="control-group">
                <label>Point A:</label>
                <input type="range" id="p1-slider" class="slider" min="0" max="1000" step="1" value="250">
            </div>
            <div class="control-group">
                <label>Point B:</label>
                <input type="range" id="p2-slider" class="slider" min="0" max="1000" step="1" value="750">
            </div>
        </div>
    </div>
    <div class="plot-container">
        <div id="plot"></div>
    </div>

    <script>
        // Detect modes
        const params = new URLSearchParams(window.location.search);
        if (params.has('embed')) document.body.classList.add('embed');

        // ==================== Functions ====================

        // Data for MSE: x = [1, 2, 3], y = [2, 4, 5], h = θx (1D, no intercept)
        // J_MSE(θ) = (1/3)[(θ−2)² + (2θ−4)² + (3θ−5)²] = (14θ²−50θ+45)/3
        const mseData = [
            { x: 1, y: 2 },
            { x: 2, y: 4 },
            { x: 3, y: 5 }
        ];

        function jMSE(theta) {
            let sum = 0;
            for (const d of mseData) sum += (theta * d.x - d.y) ** 2;
            return sum / mseData.length;
        }

        function jRidge(theta, lambda) {
            return jMSE(theta) + lambda * theta * theta;
        }

        // Non-convex: has local bumps from sine, global quadratic trend
        // Looks like a realistic loss landscape with multiple local minima
        function jNonConvex(theta) {
            return 0.1 * (theta - 2) ** 2 + Math.sin(2 * theta);
        }

        // ==================== Plot ====================

        const thetaMin = -1, thetaMax = 5;
        const nCurve = 500;

        function sliderToTheta(val) {
            return thetaMin + (val / 1000) * (thetaMax - thetaMin);
        }

        // Default slider positions per function
        const defaults = {
            mse: { p1: 250, p2: 750 },
            nonconvex: { p1: 167, p2: 417 }  // θ≈0, θ≈1.5 — chord dips below the bump
        };

        function plot() {
            const mode = document.getElementById('fn-select').value;
            const lambdaRaw = parseFloat(document.getElementById('lambda-slider').value);
            const lambda = lambdaRaw / 20;  // 0 to 5
            document.getElementById('lambda-val').textContent = lambda.toFixed(1);

            // Show/hide λ control
            document.getElementById('lambda-group').classList.toggle('hidden', mode !== 'mse');

            const p1 = sliderToTheta(document.getElementById('p1-slider').value);
            const p2 = sliderToTheta(document.getElementById('p2-slider').value);

            const fn = mode === 'mse' ? (t) => jRidge(t, lambda) : jNonConvex;

            // Curve
            const xs = [], ys = [];
            for (let i = 0; i < nCurve; i++) {
                const t = thetaMin + i * (thetaMax - thetaMin) / (nCurve - 1);
                xs.push(t);
                ys.push(fn(t));
            }

            // Points on curve
            const y1 = fn(p1), y2 = fn(p2);

            // Line segment
            const segN = 200;
            const segXs = [], segYs = [];
            for (let i = 0; i <= segN; i++) {
                const frac = i / segN;
                segXs.push(p1 + frac * (p2 - p1));
                segYs.push(y1 + frac * (y2 - y1));
            }

            // Check if chord ever dips below curve (non-convex violation)
            let violation = false;
            for (let i = 0; i <= segN; i++) {
                const t = segXs[i];
                const lineVal = segYs[i];
                const curveVal = fn(t);
                if (lineVal < curveVal - 1e-6) {
                    violation = true;
                    break;
                }
            }

            // Shade violation region (where line < curve)
            const traces = [];

            // 1. Main curve
            const curveName = mode === 'mse'
                ? (lambda > 0 ? 'J<sub>ridge</sub>(θ)' : 'J<sub>MSE</sub>(θ)')
                : 'J(θ)';
            traces.push({
                x: xs, y: ys,
                type: 'scatter', mode: 'lines',
                line: { color: '#ffd966', width: 4 },
                name: curveName,
                hoverinfo: 'skip'
            });

            // 2. Violation shading: curve on top, line on bottom, fill between
            if (violation) {
                // Collect violation segments
                const vx = [], vCurve = [], vLine = [];
                for (let i = 0; i <= segN; i++) {
                    const t = segXs[i];
                    const lineVal = segYs[i];
                    const curveVal = fn(t);
                    if (lineVal < curveVal - 1e-6) {
                        vx.push(t);
                        vCurve.push(curveVal);
                        vLine.push(lineVal);
                    }
                }
                // Lower bound (line)
                traces.push({
                    x: vx, y: vLine,
                    type: 'scatter', mode: 'lines',
                    line: { color: 'rgba(0,0,0,0)', width: 0 },
                    showlegend: false,
                    hoverinfo: 'skip'
                });
                // Upper bound (curve), fill down to previous trace
                traces.push({
                    x: vx, y: vCurve,
                    type: 'scatter', mode: 'lines',
                    line: { color: 'rgba(0,0,0,0)', width: 0 },
                    fill: 'tonexty',
                    fillcolor: 'rgba(224, 102, 102, 0.3)',
                    showlegend: false,
                    hoverinfo: 'skip'
                });
            }

            // 3. Line segment (chord)
            traces.push({
                x: segXs, y: segYs,
                type: 'scatter', mode: 'lines',
                line: { color: '#674ea7', width: 2.5, dash: 'dash' },
                name: 'chord',
                hoverinfo: 'skip'
            });

            // 4. Endpoints
            traces.push({
                x: [p1, p2], y: [y1, y2],
                type: 'scatter', mode: 'markers',
                marker: { size: 12, color: '#674ea7', line: { color: '#fff', width: 2 } },
                name: 'A, B',
                hoverinfo: 'skip'
            });

            // Title
            let title;
            if (mode === 'mse') {
                const jLabel = lambda > 0
                    ? `J<sub>ridge</sub>(θ) = J<sub>MSE</sub>(θ) + ${lambda.toFixed(1)}θ²`
                    : 'J<sub>MSE</sub>(θ) = ⅓ Σ(θxᵢ − yᵢ)²';
                title = jLabel + '  — chord ≥ curve everywhere  ✓';
            } else {
                title = violation
                    ? 'J(θ) = 0.1(θ−2)² + sin(2θ)  — chord dips below curve  ✗'
                    : 'J(θ) = 0.1(θ−2)² + sin(2θ)  — try other points to find a violation';
            }

            const layout = {
                title: { text: title, font: { size: 18 } },
                xaxis: {
                    title: { text: 'θ', font: { size: 16 } },
                    range: [thetaMin, thetaMax],
                    zeroline: false
                },
                yaxis: {
                    title: { text: 'J(θ)', font: { size: 16 } },
                    zeroline: false
                },
                margin: { l: 60, r: 30, t: 50, b: 50 },
                showlegend: false
            };

            Plotly.react('plot', traces, layout, {
                responsive: true,
                displayModeBar: false
            });
        }

        // Event listeners
        document.getElementById('fn-select').addEventListener('change', function() {
            const d = defaults[this.value];
            document.getElementById('p1-slider').value = d.p1;
            document.getElementById('p2-slider').value = d.p2;
            if (this.value !== 'mse') {
                document.getElementById('lambda-slider').value = 0;
            }
            plot();
        });
        document.getElementById('lambda-slider').addEventListener('input', plot);
        document.getElementById('p1-slider').addEventListener('input', plot);
        document.getElementById('p2-slider').addEventListener('input', plot);

        plot();
    </script>
</body>
</html>
