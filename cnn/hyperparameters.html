<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>hyperparameters</title>
    
    <!-- External Dependencies -->
    <script src="https://d3js.org/d3.v5.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f5f5f5;
        }

        .container {
            background-color: white;
            min-height: 100vh;
        }

        .main-content {
            position: relative;
            padding: 10px;
            max-width: 1250px;
            margin: 0 auto;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }


        .content-container {
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: space-between;
            flex: 1;
            padding: 20px 0;
        }

        .left-controls, .right-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 160px;
            flex-shrink: 0;
        }

        .center-visualization {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            flex: 1;
            justify-content: center;
            min-width: 0;
        }

        /* Responsive breakpoints */
        @media (max-width: 1024px) {
            .content-container {
                gap: 15px;
                padding: 15px 0;
            }
            
            .left-controls, .right-controls {
                width: 140px;
                gap: 10px;
            }
            
            .matrices-row {
                gap: 20px;
            }
            
            .matrix-container svg {
                width: 160px !important;
                height: 160px !important;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 8px;
            }
            
            .content-container {
                flex-direction: column;
                gap: 20px;
                align-items: center;
            }
            
            .left-controls, .right-controls {
                width: 100%;
                max-width: 300px;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                gap: 15px;
            }
            
            .control-group {
                min-width: 120px;
            }
            
            .matrices-row {
                flex-direction: column;
                gap: 15px;
            }
            
            .matrix-container svg {
                width: 140px !important;
                height: 140px !important;
            }
            
            .control-button {
                top: 10px;
                right: 10px;
            }
        }

        @media (max-width: 480px) {
            .main-content {
                padding: 5px;
            }
            
            .left-controls, .right-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .control-group {
                min-width: auto;
                width: 100%;
            }
            
            .control-group input[type=range] {
                width: 100%;
            }
            
            .matrix-container svg {
                width: 120px !important;
                height: 120px !important;
            }
            
            .annotation {
                font-size: 12px;
            }
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-group label {
            font-weight: 500;
            color: #4a4a4a;
            font-size: 13px;
        }

        .control-group input[type=number] {
            width: 50px;
            padding: 3px 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 11px;
        }

        .control-group input[type=range] {
            width: 140px;
        }


        .matrices-row {
            display: flex;
            flex-direction: row;
            align-items: flex-end;
            gap: 30px;
        }

        .matrix-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .matrix-header {
            text-align: center;
            font-weight: 500;
            color: #333;
            font-size: 14px;
        }

        .sub-text {
            font-size: 12px;
            color: #9a9a9a;
            margin-top: 2px;
        }

        .annotation {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            font-style: italic;
            color: #666;
        }

        .annotation img {
            width: 18px;
        }

        .is-danger {
            border-color: #f14668 !important;
            background-color: #feecf0 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="content-container">
                <div class="left-controls">
                    <div class="control-group">
                        <label>Input Size:</label>
                        <input type="number" id="inputSize" min="2" max="7" value="5">
                        <input type="range" id="inputSizeRange" min="2" max="7" value="5">
                    </div>
                </div>

                <div class="center-visualization">
                    <div class="matrices-row">
                        <div class="matrix-container">
                            <div class="matrix-header">
                                Input (<span id="inputDim"></span>, <span id="inputDim2"></span>)
                                <div class="sub-text">After-padding (<span id="paddedDim"></span>, <span id="paddedDim2"></span>)</div>
                            </div>
                            <svg id="inputSvg" width="180" height="180"></svg>
                        </div>

                        <div class="matrix-container">
                            <div class="matrix-header">
                                Output (<span id="outputDim"></span>, <span id="outputDim2"></span>)
                            </div>
                            <svg id="outputSvg" width="180" height="180"></svg>
                        </div>
                    </div>

                    <div class="annotation">
                        <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNSAyNSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEyLjUgMkM2Ljk3IDEuOTk5IDIuNDk5IDYuNDcgMi40OTkgMTJTMi45NyAyMi4wMDEgOC41IDIyLjAwMUMxNC4wMyAyMi4wMDEgMTguNTAxIDE3LjUzIDE4LjUwMSAxMlMxNC4wMyAxLjk5OSAxMi41IDJaIiBmaWxsPSIjNjY2Ii8+CjxwYXRoIGQ9Ik0xMi41IDYuNUMxMy4zMjggNi41IDE0IDcuMTcyIDE0IDhTMTMuMzI4IDkuNSAxMi41IDkuNUMxMS42NzIgOS41IDExIDguODI4IDExIDhTMTEuNjcyIDYuNSAxMi41IDYuNVoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0xMi41IDExQzEzLjMyOCAxMSAxNCAxMS42NzIgMTQgMTIuNVYxNkMxNCAxNi44MjggMTMuMzI4IDE3LjUgMTIuNSAxNy41UzExIDE2LjgyOCAxMSAxNlYxMi41QzExIDExLjY3MiAxMS42NzIgMTEgMTIuNSAxMVoiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=" alt="pointer icon" width="25px">
                        <span><strong>Hover over</strong> to change focus. <strong>Click outside</strong> to resume.</span>
                    </div>
                </div>

                <div class="right-controls">
                    <h3 style="font-size: 16px; font-weight: 600; color: #333; margin-bottom: 15px; text-align: center;">Hyperparameters</h3>
                    
                    <div class="control-group">
                        <label>Padding:</label>
                        <input type="number" id="padding" min="0" max="2" value="0">
                        <input type="range" id="paddingRange" min="0" max="2" value="0">
                    </div>

                    <div class="control-group">
                        <label>Filter Size:</label>
                        <input type="number" id="kernelSize" min="1" max="5" value="2">
                        <input type="range" id="kernelSizeRange" min="1" max="5" value="2">
                    </div>

                    <div class="control-group">
                        <label>Stride:</label>
                        <input type="number" id="stride" min="1" max="3" value="1">
                        <input type="range" id="strideRange" min="1" max="3" value="1">
                    </div>
                </div>
            </div>
            <!-- Footer -->
            <footer style="text-align: center; padding: 15px; color: #666; font-size: 13px; margin-top: auto;">
                Adapted from <a href="https://poloclub.github.io/cnn-explainer/" target="_blank" style="color: #0877bd;">CNN Explainer</a> with ❤️ by&nbsp;<a href="https://shenshen.mit.edu" target="_blank" style="color: #0877bd;">Shen²</a> | 
                <a href="https://github.com/poloclub/cnn-explainer/issues" target="_blank" style="color: #0877bd;">Bug Report</a>
            </footer>
        </div>
    </div>

    <script>
        // Utility functions extracted from the original code
        function init2DArray(height, width, fill) {
            let array = [];
            for (let r = 0; r < height; r++) {
                let row = new Array(width).fill(fill);
                array.push(row);
            }
            return array;
        }

        function generateSquareArray(size) {
            return init2DArray(size, size, 0);
        }

        function singleConv(input, kernel, stride) {
            const inputSize = input.length;
            const kernelSize = kernel.length;
            const outputSize = Math.floor((inputSize - kernelSize) / stride) + 1;
            const output = init2DArray(outputSize, outputSize, 0);

            for (let i = 0; i < outputSize; i++) {
                for (let j = 0; j < outputSize; j++) {
                    let sum = 0;
                    for (let ki = 0; ki < kernelSize; ki++) {
                        for (let kj = 0; kj < kernelSize; kj++) {
                            const inputRow = i * stride + ki;
                            const inputCol = j * stride + kj;
                            sum += input[inputRow][inputCol] * kernel[ki][kj];
                        }
                    }
                    output[i][j] = sum;
                }
            }
            return output;
        }

        function array1d(length, func) {
            return Array.from({ length }, (_, i) => func(i));
        }

        function generateOutputMappings(stride, output, kernelSize, inputSize, dilation) {
            const outputMappings = [];
            const outputLength = output.length;
            
            for (let i = 0; i < outputLength; i++) {
                for (let j = 0; j < outputLength; j++) {
                    const mapping = [];
                    for (let ki = 0; ki < kernelSize; ki++) {
                        for (let kj = 0; kj < kernelSize; kj++) {
                            const inputRow = i * stride + ki * dilation;
                            const inputCol = j * stride + kj * dilation;
                            if (inputRow < inputSize && inputCol < inputSize) {
                                mapping.push([inputRow, inputCol]);
                            }
                        }
                    }
                    outputMappings.push(mapping);
                }
            }
            return outputMappings;
        }

        function compute_input_multiplies_with_weight(outputH, outputW, inputLength, kernelLength, outputMappings, filterNum) {
            const inputHighlights = array1d(inputLength * inputLength, (i) => false);
            const outputIndex = outputH * Math.sqrt(outputMappings.length) + outputW;
            const mapping = outputMappings[outputIndex];
            
            mapping.forEach(([row, col]) => {
                inputHighlights[row * inputLength + col] = true;
            });
            
            return inputHighlights;
        }

        // State management
        const state = {
            inputSize: 5,
            padding: 0,
            kernelSize: 2,
            stride: 1,
            isPaused: false,
            isStrideValid: true,
            counter: 0,
            interval: null,
            input: null,
            kernel: null,
            output: null,
            inputHighlights: [],
            outputHighlights: []
        };

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            updateConstraints();
            updateVisualization();
        });

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                updateVisualization();
            }, 250);
        });

        function setupEventListeners() {
            // Input size controls
            document.getElementById('inputSize').addEventListener('input', (e) => {
                state.inputSize = parseInt(e.target.value);
                document.getElementById('inputSizeRange').value = state.inputSize;
                updateConstraints();
                updateVisualization();
            });

            document.getElementById('inputSizeRange').addEventListener('input', (e) => {
                state.inputSize = parseInt(e.target.value);
                document.getElementById('inputSize').value = state.inputSize;
                updateConstraints();
                updateVisualization();
            });

            // Padding controls
            document.getElementById('padding').addEventListener('input', (e) => {
                state.padding = parseInt(e.target.value);
                document.getElementById('paddingRange').value = state.padding;
                updateConstraints();
                updateVisualization();
            });

            document.getElementById('paddingRange').addEventListener('input', (e) => {
                state.padding = parseInt(e.target.value);
                document.getElementById('padding').value = state.padding;
                updateConstraints();
                updateVisualization();
            });

            // Kernel size controls
            document.getElementById('kernelSize').addEventListener('input', (e) => {
                state.kernelSize = parseInt(e.target.value);
                document.getElementById('kernelSizeRange').value = state.kernelSize;
                updateConstraints();
                updateVisualization();
            });

            document.getElementById('kernelSizeRange').addEventListener('input', (e) => {
                state.kernelSize = parseInt(e.target.value);
                document.getElementById('kernelSize').value = state.kernelSize;
                updateConstraints();
                updateVisualization();
            });

            // Stride controls
            document.getElementById('stride').addEventListener('input', (e) => {
                state.stride = parseInt(e.target.value);
                document.getElementById('strideRange').value = state.stride;
                updateConstraints();
                updateVisualization();
            });

            document.getElementById('strideRange').addEventListener('input', (e) => {
                state.stride = parseInt(e.target.value);
                document.getElementById('stride').value = state.stride;
                updateConstraints();
                updateVisualization();
            });

            // Click outside matrices to resume animation
            document.addEventListener('click', (e) => {
                const inputSvg = document.getElementById('inputSvg');
                const outputSvg = document.getElementById('outputSvg');
                
                // Check if click is outside both SVGs
                if (!inputSvg.contains(e.target) && 
                    !outputSvg.contains(e.target) &&
                    state.isPaused) {
                    state.isPaused = false;
                    resumeAnimation();
                }
            });
        }

        function updateConstraints() {
            const inputSizeWithPadding = state.inputSize + 2 * state.padding;
            
            // Update max values for inputs
            document.getElementById('inputSize').max = 7;
            document.getElementById('inputSizeRange').max = 7;
            
            document.getElementById('padding').max = Math.max(0, state.kernelSize - 1);
            document.getElementById('paddingRange').max = Math.max(0, state.kernelSize - 1);
            
            document.getElementById('kernelSize').max = inputSizeWithPadding;
            document.getElementById('kernelSizeRange').max = inputSizeWithPadding;
            
            const maxStride = Math.max(inputSizeWithPadding - state.kernelSize + 1, 2);
            document.getElementById('stride').max = maxStride;
            document.getElementById('strideRange').max = maxStride;

            // Validate stride
            const stepSize = (inputSizeWithPadding - state.kernelSize) / state.stride + 1;
            const strideInput = document.getElementById('stride');
            if (Number.isInteger(stepSize)) {
                strideInput.classList.remove('is-danger');
                state.isStrideValid = true;
            } else {
                if (!strideInput.classList.contains('is-danger')) {
                    strideInput.classList.add('is-danger');
                }
                state.isStrideValid = false;
            }
        }

        function updateVisualization() {
            const inputSizeWithPadding = state.inputSize + 2 * state.padding;
            const input = generateSquareArray(inputSizeWithPadding);
            const kernel = generateSquareArray(state.kernelSize);
            const output = singleConv(input, kernel, state.stride);

            // Update dimension displays
            document.getElementById('inputDim').textContent = state.inputSize;
            document.getElementById('inputDim2').textContent = state.inputSize;
            document.getElementById('paddedDim').textContent = inputSizeWithPadding;
            document.getElementById('paddedDim2').textContent = inputSizeWithPadding;
            document.getElementById('outputDim').textContent = output.length;
            document.getElementById('outputDim2').textContent = output.length;

            // Calculate SVG size based on available space
            const centerViz = document.querySelector('.center-visualization');
            const matricesRow = document.querySelector('.matrices-row');
            const availableWidth = centerViz.clientWidth;
            const svgSize = Math.min(Math.floor((availableWidth - 60) / 2), 400); // 60px for gap between matrices
            
            // Update SVG dimensions
            document.getElementById('inputSvg').setAttribute('width', svgSize);
            document.getElementById('inputSvg').setAttribute('height', svgSize);
            document.getElementById('outputSvg').setAttribute('width', svgSize);
            document.getElementById('outputSvg').setAttribute('height', svgSize);

            // Calculate consistent cell size based on the larger matrix
            const maxDim = Math.max(input.length, output.length);
            const cellSize = svgSize / maxDim;

            // Draw grids with consistent cell size
            drawGrid('inputSvg', input, state.padding, false, cellSize);
            drawGrid('outputSvg', output, 0, true, cellSize);

            // Start animation
            startConvolution(input, kernel, output);
        }

        function drawGrid(svgId, matrix, padding, isOutput, cellSize) {
            const svg = d3.select(`#${svgId}`);
            svg.selectAll("*").remove();

            const standardCellColor = "#ddd";
            const paddingCellColor = "#aaa";

            for (let row = 0; row < matrix.length; row++) {
                for (let col = 0; col < matrix.length; col++) {
                    const rect = svg.append("rect")
                        .attr("x", col * cellSize)
                        .attr("y", row * cellSize)
                        .attr("width", cellSize)
                        .attr("height", cellSize)
                        .style("opacity", 0.5)
                        .style("stroke", "black")
                        .style("fill", function() {
                            if (!isOutput && (row < padding || row >= matrix.length - padding ||
                                col < padding || col >= matrix.length - padding)) {
                                return paddingCellColor;
                            }
                            return standardCellColor;
                        });

                    if (!isOutput) {
                        rect.on('mouseover', function() {
                            if (!state.isStrideValid) return;
                            handleMouseover(row, col, matrix);
                        });
                    }
                }
            }
        }

        function startConvolution(input, kernel, output) {
            if (state.interval) clearInterval(state.interval);
            
            state.counter = 0;
            state.input = input;
            state.kernel = kernel;
            state.output = output;
            
            if (state.isPaused || !state.isStrideValid) return;
            
            state.interval = setInterval(() => {
                if (state.isPaused || !state.isStrideValid) return;
                
                const flat_animated = state.counter % (output.length * output.length);
                state.outputHighlights = array1d(output.length * output.length, (i) => false);
                const animatedH = Math.floor(flat_animated / output.length);
                const animatedW = flat_animated % output.length;
                state.outputHighlights[animatedH * output.length + animatedW] = true;
                
                const outputMappings = generateOutputMappings(state.stride, output, kernel.length, input.length, 1);
                state.inputHighlights = compute_input_multiplies_with_weight(animatedH, animatedW, input.length, kernel.length, outputMappings, kernel.length);
                
                updateHighlights();
                state.counter++;
            }, 1000);
        }

        function resumeAnimation() {
            if (state.interval) clearInterval(state.interval);
            if (!state.input || !state.kernel || !state.output || !state.isStrideValid) return;
            
            // Find current focus position from outputHighlights
            let currentIndex = state.outputHighlights.findIndex(h => h === true);
            if (currentIndex === -1) currentIndex = 0;
            
            // Set counter to current position
            state.counter = currentIndex;
            
            state.interval = setInterval(() => {
                if (state.isPaused || !state.isStrideValid) return;
                
                const flat_animated = state.counter % (state.output.length * state.output.length);
                state.outputHighlights = array1d(state.output.length * state.output.length, (i) => false);
                const animatedH = Math.floor(flat_animated / state.output.length);
                const animatedW = flat_animated % state.output.length;
                state.outputHighlights[animatedH * state.output.length + animatedW] = true;
                
                const outputMappings = generateOutputMappings(state.stride, state.output, state.kernel.length, state.input.length, 1);
                state.inputHighlights = compute_input_multiplies_with_weight(animatedH, animatedW, state.input.length, state.kernel.length, outputMappings, state.kernel.length);
                
                updateHighlights();
                state.counter++;
            }, 1000);
        }

        function handleMouseover(row, col, matrix) {
            const outputMappings = generateOutputMappings(state.stride, state.output, state.kernel.length, matrix.length, 1);
            state.outputHighlights = array1d(state.output.length * state.output.length, (i) => false);
            const hoverH = Math.min(Math.floor(row / state.stride), state.output.length - 1);
            const hoverW = Math.min(Math.floor(col / state.stride), state.output.length - 1);
            state.outputHighlights[hoverH * state.output.length + hoverW] = true;
            state.inputHighlights = compute_input_multiplies_with_weight(hoverH, hoverW, matrix.length, state.kernel.length, outputMappings, state.kernel.length);
            
            state.isPaused = true;
            
            updateHighlights();
        }

        function updateHighlights() {
            // Update input highlights
            const inputSvg = d3.select('#inputSvg');
            const inputRects = inputSvg.selectAll('rect');
            inputRects.each(function(d, i) {
                const rect = d3.select(this);
                if (state.inputHighlights[i]) {
                    rect.style('fill', '#ff6b6b');
                    rect.style('opacity', 0.8);
                } else {
                    const row = Math.floor(i / state.input.length);
                    const col = i % state.input.length;
                    const isPadding = row < state.padding || row >= state.input.length - state.padding ||
                                    col < state.padding || col >= state.input.length - state.padding;
                    rect.style('fill', isPadding ? '#aaa' : '#ddd');
                    rect.style('opacity', 0.5);
                }
            });

            // Update output highlights
            const outputSvg = d3.select('#outputSvg');
            const outputRects = outputSvg.selectAll('rect');
            outputRects.each(function(d, i) {
                const rect = d3.select(this);
                if (state.outputHighlights[i]) {
                    rect.style('fill', '#4ecdc4');
                    rect.style('opacity', 0.8);
                } else {
                    rect.style('fill', '#ddd');
                    rect.style('opacity', 0.5);
                }
            });
        }
    </script>
</body>
</html>

